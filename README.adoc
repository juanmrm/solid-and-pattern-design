= SOLID and Design Patterns

Principios basicos de la POO (Programación Orientada a Objetos).

- S -> Single responsability principle.

- O -> Open / Closed principle.

- L -> Liskov substitution principle.

- I -> Interface segregation principle.

- D -> Dependency Inversion principle.

== Patterns
'''

En general los autores favorecen o se decantan por usar la composición en lugar de la herencia.

=== Creational

Facilitan la creación de objetos ocultando la lógica de creación y evitando el tener que usar el operador new directamente.
Proporciona más flexibilidad al programa a la hora de decidir que objetos necesitan ser creados para un determinado caso de uso.

- Abstract Factory: factoría de factorías. Crea una instancia de varias familias de clases.

- Builder:  construcción de un objeto complejo paso a paso a partir de objetos sencillos.
Separa la construcción del objeto de su representación.

- Factory Method: lo utilizamos para crear objetos sin tener que especificar la clase exacta del objeto de que queremos crear y sin llamar a su constructor directamente.
Esto lo conseguimos creando los objetos con el factory method especificado en una interfaz e implementado en clases o en una clase base y sobreescrito en las clases que la extiendebn.

- Prototype: creamos una instancia nueva a partir de otra ya existente que sirve como prototipo. Se usa cuando la creación de una instancia totalmente nueva es muy costosa.

- Clone: crea un nuevo objeto del mismo tipo y copia todos sus campos.

- Singleton: se asegura de que solo existe una instancia de la clase y proporciona un unico punto de acceso global a ella. El constructor debe ser privado.

=== Structural

Se refieren a la composición de clases y objetos. El concepto de herencia se usa para componer interfaces y definir formas de componer objetos para obtener nuevas funcionalidades.

- Adapter: la motivación es convertir la interfaz de una clase en otra interfaz que los clientes esperan. Permite que las clases funcionen juntas, lo que de otra forma no podría ser debido a interfaces incompatibles.

- Bridge: usado cuando tenemos que desacoplar una abstracción de su implementación para que las 2 partes puedan modificarse independientemente.

- Composite: permite que el cliente trate objetos individuales y compuestos de forma uniforme. Esta clase proporciona formas de modificar su grupo de objetos.

- Decorator: la motivacion es agregar nuevas funcionalidades a un objeto existente sin alterar su estructura. Crea una clase de decorador que envuelve la clase original y proporciona la uncionalidad adicional pero manteniendo la firma de los métodos de clase intactos.

- Facade: la motivacion es ocultar las complejidades del sistema y proporcionar una interfaz al cliente pero simplificada. Incluye una sola clase que proporciona métodos simplificados requeridos por el cliente y delega llamadas a métodos de clases de sistema existentes.
Esto no implica que no vayamos a poder acceder a los sistemas de más bajo nivel, simplemente es una interfaz de más alto nivel que nos simplificará ciertas operaciones.

- Flyweight: usado principalmente para reducir la cantidad de objetos creados y disminuir el uso de memoria (+ rendimiento). Proporciona formas de disminuir la cantidad de objetos, mejorando así la estructura de objetos de la aplicación.

- Proxy: la motivacion es controlar el acceso y lo hace proporcionando un substituto de otro objeto (real-object) y añadiendo restricciones.

- Virtual Proxy: la motivación en este caso es el performance. Retrasa la creación del objeto real al máximo. Se crea la instancia del objeto real la primera vez que el cliente realiza una solicitud al proxy.
Este recuerda la identidad de este objeto real y reenvía la solicitud a este objeto real. Luego, todas las solicitudes posteriores simplemente se reenvían directamente al objeto real encapsulado evitando la creación n veces.